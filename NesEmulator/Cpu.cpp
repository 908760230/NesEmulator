#include "Cpu.h"
#include "Bus.h"

Cpu::Cpu() {
    instructions = { 
        { "BRK", &Cpu::BRK, &Cpu::IMM, 7 },{ "ORA", &Cpu::ORA, &Cpu::IZX, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 8 },{ "???", &Cpu::NOP, &Cpu::IMP, 3 },{ "ORA", &Cpu::ORA, &Cpu::ZP0, 3 },{ "ASL", &Cpu::ASL, &Cpu::ZP0, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 5 },{ "PHP", &Cpu::PHP, &Cpu::IMP, 3 },{ "ORA", &Cpu::ORA, &Cpu::IMM, 2 },{ "ASL", &Cpu::ASL, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "???", &Cpu::NOP, &Cpu::IMP, 4 },{ "ORA", &Cpu::ORA, &Cpu::ABS, 4 },{ "ASL", &Cpu::ASL, &Cpu::ABS, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },
        { "BPL", &Cpu::BPL, &Cpu::REL, 2 },{ "ORA", &Cpu::ORA, &Cpu::IZY, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 8 },{ "???", &Cpu::NOP, &Cpu::IMP, 4 },{ "ORA", &Cpu::ORA, &Cpu::ZPX, 4 },{ "ASL", &Cpu::ASL, &Cpu::ZPX, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },{ "CLC", &Cpu::CLC, &Cpu::IMP, 2 },{ "ORA", &Cpu::ORA, &Cpu::ABY, 4 },{ "???", &Cpu::NOP, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 7 },{ "???", &Cpu::NOP, &Cpu::IMP, 4 },{ "ORA", &Cpu::ORA, &Cpu::ABX, 4 },{ "ASL", &Cpu::ASL, &Cpu::ABX, 7 },{ "???", &Cpu::XXX, &Cpu::IMP, 7 },
        { "JSR", &Cpu::JSR, &Cpu::ABS, 6 },{ "AND", &Cpu::AND, &Cpu::IZX, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 8 },{ "BIT", &Cpu::BIT, &Cpu::ZP0, 3 },{ "AND", &Cpu::AND, &Cpu::ZP0, 3 },{ "ROL", &Cpu::ROL, &Cpu::ZP0, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 5 },{ "PLP", &Cpu::PLP, &Cpu::IMP, 4 },{ "AND", &Cpu::AND, &Cpu::IMM, 2 },{ "ROL", &Cpu::ROL, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "BIT", &Cpu::BIT, &Cpu::ABS, 4 },{ "AND", &Cpu::AND, &Cpu::ABS, 4 },{ "ROL", &Cpu::ROL, &Cpu::ABS, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },
        { "BMI", &Cpu::BMI, &Cpu::REL, 2 },{ "AND", &Cpu::AND, &Cpu::IZY, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 8 },{ "???", &Cpu::NOP, &Cpu::IMP, 4 },{ "AND", &Cpu::AND, &Cpu::ZPX, 4 },{ "ROL", &Cpu::ROL, &Cpu::ZPX, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },{ "SEC", &Cpu::SEC, &Cpu::IMP, 2 },{ "AND", &Cpu::AND, &Cpu::ABY, 4 },{ "???", &Cpu::NOP, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 7 },{ "???", &Cpu::NOP, &Cpu::IMP, 4 },{ "AND", &Cpu::AND, &Cpu::ABX, 4 },{ "ROL", &Cpu::ROL, &Cpu::ABX, 7 },{ "???", &Cpu::XXX, &Cpu::IMP, 7 },
        { "RTI", &Cpu::RTI, &Cpu::IMP, 6 },{ "EOR", &Cpu::EOR, &Cpu::IZX, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 8 },{ "???", &Cpu::NOP, &Cpu::IMP, 3 },{ "EOR", &Cpu::EOR, &Cpu::ZP0, 3 },{ "LSR", &Cpu::LSR, &Cpu::ZP0, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 5 },{ "PHA", &Cpu::PHA, &Cpu::IMP, 3 },{ "EOR", &Cpu::EOR, &Cpu::IMM, 2 },{ "LSR", &Cpu::LSR, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "JMP", &Cpu::JMP, &Cpu::ABS, 3 },{ "EOR", &Cpu::EOR, &Cpu::ABS, 4 },{ "LSR", &Cpu::LSR, &Cpu::ABS, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },
        { "BVC", &Cpu::BVC, &Cpu::REL, 2 },{ "EOR", &Cpu::EOR, &Cpu::IZY, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 8 },{ "???", &Cpu::NOP, &Cpu::IMP, 4 },{ "EOR", &Cpu::EOR, &Cpu::ZPX, 4 },{ "LSR", &Cpu::LSR, &Cpu::ZPX, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },{ "CLI", &Cpu::CLI, &Cpu::IMP, 2 },{ "EOR", &Cpu::EOR, &Cpu::ABY, 4 },{ "???", &Cpu::NOP, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 7 },{ "???", &Cpu::NOP, &Cpu::IMP, 4 },{ "EOR", &Cpu::EOR, &Cpu::ABX, 4 },{ "LSR", &Cpu::LSR, &Cpu::ABX, 7 },{ "???", &Cpu::XXX, &Cpu::IMP, 7 },
        { "RTS", &Cpu::RTS, &Cpu::IMP, 6 },{ "ADC", &Cpu::ADC, &Cpu::IZX, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 8 },{ "???", &Cpu::NOP, &Cpu::IMP, 3 },{ "ADC", &Cpu::ADC, &Cpu::ZP0, 3 },{ "ROR", &Cpu::ROR, &Cpu::ZP0, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 5 },{ "PLA", &Cpu::PLA, &Cpu::IMP, 4 },{ "ADC", &Cpu::ADC, &Cpu::IMM, 2 },{ "ROR", &Cpu::ROR, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "JMP", &Cpu::JMP, &Cpu::IND, 5 },{ "ADC", &Cpu::ADC, &Cpu::ABS, 4 },{ "ROR", &Cpu::ROR, &Cpu::ABS, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },
        { "BVS", &Cpu::BVS, &Cpu::REL, 2 },{ "ADC", &Cpu::ADC, &Cpu::IZY, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 8 },{ "???", &Cpu::NOP, &Cpu::IMP, 4 },{ "ADC", &Cpu::ADC, &Cpu::ZPX, 4 },{ "ROR", &Cpu::ROR, &Cpu::ZPX, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },{ "SEI", &Cpu::SEI, &Cpu::IMP, 2 },{ "ADC", &Cpu::ADC, &Cpu::ABY, 4 },{ "???", &Cpu::NOP, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 7 },{ "???", &Cpu::NOP, &Cpu::IMP, 4 },{ "ADC", &Cpu::ADC, &Cpu::ABX, 4 },{ "ROR", &Cpu::ROR, &Cpu::ABX, 7 },{ "???", &Cpu::XXX, &Cpu::IMP, 7 },
        { "???", &Cpu::NOP, &Cpu::IMP, 2 },{ "STA", &Cpu::STA, &Cpu::IZX, 6 },{ "???", &Cpu::NOP, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },{ "STY", &Cpu::STY, &Cpu::ZP0, 3 },{ "STA", &Cpu::STA, &Cpu::ZP0, 3 },{ "STX", &Cpu::STX, &Cpu::ZP0, 3 },{ "???", &Cpu::XXX, &Cpu::IMP, 3 },{ "DEY", &Cpu::DEY, &Cpu::IMP, 2 },{ "???", &Cpu::NOP, &Cpu::IMP, 2 },{ "TXA", &Cpu::TXA, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "STY", &Cpu::STY, &Cpu::ABS, 4 },{ "STA", &Cpu::STA, &Cpu::ABS, 4 },{ "STX", &Cpu::STX, &Cpu::ABS, 4 },{ "???", &Cpu::XXX, &Cpu::IMP, 4 },
        { "BCC", &Cpu::BCC, &Cpu::REL, 2 },{ "STA", &Cpu::STA, &Cpu::IZY, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },{ "STY", &Cpu::STY, &Cpu::ZPX, 4 },{ "STA", &Cpu::STA, &Cpu::ZPX, 4 },{ "STX", &Cpu::STX, &Cpu::ZPY, 4 },{ "???", &Cpu::XXX, &Cpu::IMP, 4 },{ "TYA", &Cpu::TYA, &Cpu::IMP, 2 },{ "STA", &Cpu::STA, &Cpu::ABY, 5 },{ "TXS", &Cpu::TXS, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 5 },{ "???", &Cpu::NOP, &Cpu::IMP, 5 },{ "STA", &Cpu::STA, &Cpu::ABX, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 5 },
        { "LDY", &Cpu::LDY, &Cpu::IMM, 2 },{ "LDA", &Cpu::LDA, &Cpu::IZX, 6 },{ "LDX", &Cpu::LDX, &Cpu::IMM, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },{ "LDY", &Cpu::LDY, &Cpu::ZP0, 3 },{ "LDA", &Cpu::LDA, &Cpu::ZP0, 3 },{ "LDX", &Cpu::LDX, &Cpu::ZP0, 3 },{ "???", &Cpu::XXX, &Cpu::IMP, 3 },{ "TAY", &Cpu::TAY, &Cpu::IMP, 2 },{ "LDA", &Cpu::LDA, &Cpu::IMM, 2 },{ "TAX", &Cpu::TAX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "LDY", &Cpu::LDY, &Cpu::ABS, 4 },{ "LDA", &Cpu::LDA, &Cpu::ABS, 4 },{ "LDX", &Cpu::LDX, &Cpu::ABS, 4 },{ "???", &Cpu::XXX, &Cpu::IMP, 4 },
        { "BCS", &Cpu::BCS, &Cpu::REL, 2 },{ "LDA", &Cpu::LDA, &Cpu::IZY, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 5 },{ "LDY", &Cpu::LDY, &Cpu::ZPX, 4 },{ "LDA", &Cpu::LDA, &Cpu::ZPX, 4 },{ "LDX", &Cpu::LDX, &Cpu::ZPY, 4 },{ "???", &Cpu::XXX, &Cpu::IMP, 4 },{ "CLV", &Cpu::CLV, &Cpu::IMP, 2 },{ "LDA", &Cpu::LDA, &Cpu::ABY, 4 },{ "TSX", &Cpu::TSX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 4 },{ "LDY", &Cpu::LDY, &Cpu::ABX, 4 },{ "LDA", &Cpu::LDA, &Cpu::ABX, 4 },{ "LDX", &Cpu::LDX, &Cpu::ABY, 4 },{ "???", &Cpu::XXX, &Cpu::IMP, 4 },
        { "CPY", &Cpu::CPY, &Cpu::IMM, 2 },{ "CMP", &Cpu::CMP, &Cpu::IZX, 6 },{ "???", &Cpu::NOP, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 8 },{ "CPY", &Cpu::CPY, &Cpu::ZP0, 3 },{ "CMP", &Cpu::CMP, &Cpu::ZP0, 3 },{ "DEC", &Cpu::DEC, &Cpu::ZP0, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 5 },{ "INY", &Cpu::INY, &Cpu::IMP, 2 },{ "CMP", &Cpu::CMP, &Cpu::IMM, 2 },{ "DEX", &Cpu::DEX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "CPY", &Cpu::CPY, &Cpu::ABS, 4 },{ "CMP", &Cpu::CMP, &Cpu::ABS, 4 },{ "DEC", &Cpu::DEC, &Cpu::ABS, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },
        { "BNE", &Cpu::BNE, &Cpu::REL, 2 },{ "CMP", &Cpu::CMP, &Cpu::IZY, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 8 },{ "???", &Cpu::NOP, &Cpu::IMP, 4 },{ "CMP", &Cpu::CMP, &Cpu::ZPX, 4 },{ "DEC", &Cpu::DEC, &Cpu::ZPX, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },{ "CLD", &Cpu::CLD, &Cpu::IMP, 2 },{ "CMP", &Cpu::CMP, &Cpu::ABY, 4 },{ "NOP", &Cpu::NOP, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 7 },{ "???", &Cpu::NOP, &Cpu::IMP, 4 },{ "CMP", &Cpu::CMP, &Cpu::ABX, 4 },{ "DEC", &Cpu::DEC, &Cpu::ABX, 7 },{ "???", &Cpu::XXX, &Cpu::IMP, 7 },
        { "CPX", &Cpu::CPX, &Cpu::IMM, 2 },{ "SBC", &Cpu::SBC, &Cpu::IZX, 6 },{ "???", &Cpu::NOP, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 8 },{ "CPX", &Cpu::CPX, &Cpu::ZP0, 3 },{ "SBC", &Cpu::SBC, &Cpu::ZP0, 3 },{ "INC", &Cpu::INC, &Cpu::ZP0, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 5 },{ "INX", &Cpu::INX, &Cpu::IMP, 2 },{ "SBC", &Cpu::SBC, &Cpu::IMM, 2 },{ "NOP", &Cpu::NOP, &Cpu::IMP, 2 },{ "???", &Cpu::SBC, &Cpu::IMP, 2 },{ "CPX", &Cpu::CPX, &Cpu::ABS, 4 },{ "SBC", &Cpu::SBC, &Cpu::ABS, 4 },{ "INC", &Cpu::INC, &Cpu::ABS, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },
        { "BEQ", &Cpu::BEQ, &Cpu::REL, 2 },{ "SBC", &Cpu::SBC, &Cpu::IZY, 5 },{ "???", &Cpu::XXX, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 8 },{ "???", &Cpu::NOP, &Cpu::IMP, 4 },{ "SBC", &Cpu::SBC, &Cpu::ZPX, 4 },{ "INC", &Cpu::INC, &Cpu::ZPX, 6 },{ "???", &Cpu::XXX, &Cpu::IMP, 6 },{ "SED", &Cpu::SED, &Cpu::IMP, 2 },{ "SBC", &Cpu::SBC, &Cpu::ABY, 4 },{ "NOP", &Cpu::NOP, &Cpu::IMP, 2 },{ "???", &Cpu::XXX, &Cpu::IMP, 7 },{ "???", &Cpu::NOP, &Cpu::IMP, 4 },{ "SBC", &Cpu::SBC, &Cpu::ABX, 4 },{ "INC", &Cpu::INC, &Cpu::ABX, 7 },{ "???", &Cpu::XXX, &Cpu::IMP, 7 },

    };
}

Cpu::~Cpu()
{
}

void Cpu::write(uint16_t addr, uint8_t data)
{
    busPtr->write(addr, data);
}

uint8_t Cpu::read(uint16_t addr)
{
    return busPtr->read(addr);
}

uint8_t Cpu::getFlag(FLAGS flag)
{
    if ((status & flag) > 0) return 1;
    return 0;
}

void Cpu::setFlag(FLAGS flag, bool value)
{
    if (value) {
        status |= flag;
    }
    else status &= ~flag;  //Çå³ý
}

std::map<uint16_t, std::string> Cpu::disassemble(uint16_t start, uint16_t end)
{
    uint32_t addr = start;
    uint8_t value = 0x00, high = 0x00, low = 0x00;
    std::map<uint16_t, std::string> mapLines;
    uint16_t lineAddr = 0;

    auto hex = [](uint32_t n, uint8_t d)
    {
        std::string s(d, '0');
        for (int i = d - 1; i >= 0; i--, n >>= 4)
            s[i] = "0123456789ABCDEF"[n & 0xF];
        return s;
    };

    while (addr <= (uint32_t)end)
    {
        lineAddr = addr;

        // Prefix line with instruction address
        std::string sInst = "$" + hex(addr, 4) + ": ";

        // Read instruction, and get its readable name
        uint8_t opcode = busPtr->read(addr, true); addr++;
        sInst += instructions[opcode].name + " ";

        // Get oprands from desired locations, and form the
        // instruction based upon its addressing mode. These
        // routines mimmick the actual fetch routine of the
        // 6502 in order to get accurate data as part of the
        // instruction
        if (instructions[opcode].mode == &Cpu::IMP)
        {
            sInst += " {IMP}";
        }
        else if (instructions[opcode].mode == &Cpu::IMM)
        {
            value = busPtr->read(addr, true); addr++;
            sInst += "#$" + hex(value, 2) + " {IMM}";
        }
        else if (instructions[opcode].mode == &Cpu::ZP0)
        {
            low = busPtr->read(addr, true); addr++;
            high = 0x00;
            sInst += "$" + hex(low, 2) + " {ZP0}";
        }
        else if (instructions[opcode].mode == &Cpu::ZPX)
        {
            low = busPtr->read(addr, true); addr++;
            high = 0x00;
            sInst += "$" + hex(low, 2) + ", X {ZPX}";
        }
        else if (instructions[opcode].mode == &Cpu::ZPY)
        {
            low = busPtr->read(addr, true); addr++;
            high = 0x00;
            sInst += "$" + hex(low, 2) + ", Y {ZPY}";
        }
        else if (instructions[opcode].mode == &Cpu::IZX)
        {
            low = busPtr->read(addr, true); addr++;
            high = 0x00;
            sInst += "($" + hex(low, 2) + ", X) {IZX}";
        }
        else if (instructions[opcode].mode == &Cpu::IZY)
        {
            low = busPtr->read(addr, true); addr++;
            high = 0x00;
            sInst += "($" + hex(low, 2) + "), Y {IZY}";
        }
        else if (instructions[opcode].mode == &Cpu::ABS)
        {
            low = busPtr->read(addr, true); addr++;
            high = busPtr->read(addr, true); addr++;
            sInst += "$" + hex((uint16_t)(high << 8) | low, 4) + " {ABS}";
        }
        else if (instructions[opcode].mode == &Cpu::ABX)
        {
            low = busPtr->read(addr, true); addr++;
            high = busPtr->read(addr, true); addr++;
            sInst += "$" + hex((uint16_t)(high << 8) | low, 4) + ", X {ABX}";
        }
        else if (instructions[opcode].mode == &Cpu::ABY)
        {
            low = busPtr->read(addr, true); addr++;
            high = busPtr->read(addr, true); addr++;
            sInst += "$" + hex((uint16_t)(high << 8) | low, 4) + ", Y {ABY}";
        }
        else if (instructions[opcode].mode == &Cpu::IND)
        {
            low = busPtr->read(addr, true); addr++;
            high = busPtr->read(addr, true); addr++;
            sInst += "($" + hex((uint16_t)(high << 8) | low, 4) + ") {IND}";
        }
        else if (instructions[opcode].mode == &Cpu::REL)
        {
            value = busPtr->read(addr, true); addr++;
            sInst += "$" + hex(value, 2) + " [$" + hex(addr + value, 4) + "] {REL}";
        }

        // Add the formed string to a std::map, using the instruction's
        // address as the key. This makes it convenient to look for later
        // as the instructions are variable in length, so a straight up
        // incremental index is not sufficient.
        mapLines[lineAddr] = sInst;
    }

    return mapLines;
}

//Ö´ÐÐ¼òµ¥µÄ²Ù×÷£¬ÀýÈçÉèÖÃ×´Ì¬Î»¡£ÕâÀïÉèÖÃ¸³ÖµÎªÀÛ¼ÓÆ÷ÒÔ»ñÈ¡ÀàËÆPHAÖ¸Áî¡£
inline uint8_t Cpu::IMP() {
    fetched = accumulator;
    return 0;
}

//Ö±½ÓÈ¡Ò»¸ö×Ö½ÚµÄÖµ
inline uint8_t Cpu::IMM() {
    addrABS = pc++;
    return 0;
}

// ÒÔ¾ø¶ÔµØÖ·µÄÐÎÊ½·ÃÎÊ 0x0000~0x00FF
uint8_t Cpu::ZP0()
{   
    addrABS = read(pc);
    pc++;
    addrABS &= 0x00FF;
    return 0;
}

// ÓëÁãÒ³Ñ°Ö·ÏàÍ¬£¬µ«x¼Ä´æÆ÷µÄÄÚÈÝ»áÌí¼Óµ½µ¥×Ö½ÚµØÖ·ÖÐ
uint8_t Cpu::ZPX()
{
    addrABS = read(pc) + x;
    pc++;
    addrABS &= 0x00FF;
    return 0;
}


//y¼Ä´æÆ÷µÄÄÚÈÝ»áÌí¼Óµ½µ¥×Ö½ÚµØÖ·ÖÐ
uint8_t Cpu::ZPY()
{
    addrABS = read(pc) + y;
    pc++;
    addrABS &= 0x00FF;

    return 0;
}

// ·ÖÖ§Ö¸Áî¶ÀÓÐµÄÑ°Ö·Ä£Ê½£¬ÆäµØÖ·±ØÐëÎ»ÓÚ·ÖÖ§Ö¸ÁîµÄ-128 ~ 127Ö®¼ä
uint8_t Cpu::REL()
{
    addrREL = read(pc);
    pc++;
    if (addrREL & 0x80) addrREL |= 0xFF00;
    return 0;
}

// 16 bit ¶¼»á±»Ê¹ÓÃ
uint8_t Cpu::ABS()
{
    uint16_t low = read(pc);
    pc++;
    uint16_t high = read(pc);
    pc++;
    addrABS = (high << 8) | low;
    return 0;
}

// ÔÚ¾ø¶ÔµØÖ·µÄ»ù´¡ÉÏ¼ÓÉÏ ¼Ä´æÆ÷xµÄÖµ
uint8_t Cpu::ABX()
{
    uint16_t low = read(pc);
    pc++;
    uint16_t high = read(pc);
    pc++;
    addrABS = (high << 8) | low;
    addrABS += x;

    if ((addrABS & 0xFF00) != (high << 8)) return 1; // ÅÐ¶ÏÔ½½ç
    return 0;
}

uint8_t Cpu::ABY()
{
    uint16_t low = read(pc);
    pc++;
    uint16_t high = read(pc);
    pc++;
    addrABS = (high << 8) | low;
    addrABS += y;

    if ((addrABS & 0xFF00) != (high << 8)) return 1; // ÅÐ¶ÏÔ½½ç
    return 0;
}

uint8_t Cpu::IND()
{
    uint16_t ptr_low = read(pc);
    pc++;
    uint16_t ptr_high = read(pc);
    pc++;

    uint16_t ptr = (ptr_high << 8) | ptr_low;

    if (ptr_low == 0x00FF) // Ä£ÄâÓ²¼þbug
        addrABS = (read(ptr_high & 0xFF00) << 8) | read(ptr + 0); // ÎÞÐ§µÄµØÖ·
    else
        addrABS = (read(ptr + 1) << 8) | read(ptr + 0);

    return 0;
}

// ÏÈÍ¨¹ýpcµÃµ½Ïà¶ÔµØÖ·£¬ÔÙÍ¨¹ýXµÄÆ«ÒÆÁ¿ À´»ñÈ¡×îÖÕµØÖ·
uint8_t Cpu::IZX()
{
    uint16_t addr = read(pc);
    pc++;
    addr += (uint16_t)x;
    
    uint16_t addr_low = read( addr & 0x00FF);
    uint16_t addr_high = read((uint16_t)(addr + 1) & 0x00FF);
    
    addrABS = (addr_high << 8) | addr_low;
    return 0;
}

// ÏÈ¼ä½ÓÑ°Ö·¸ßµÍÎ»£¬µÃµ½Ïà¶ÔÓ¦µÄ16bitµØÖ·£¬È»ºóÔÙÀûÓÃ¼Ä´æÆ÷YµÄÖµµÃµ½×îÖÕµÄµØÖ·
uint8_t Cpu::IZY()
{
    uint16_t addr = read(pc);
    pc++;

    uint16_t addr_low = read(addr & 0x00FF);
    uint16_t addr_high = read((addr + 1) & 0x00FF);

    addrABS = (addr_high << 8) | addr_low;
    addrABS += y;

    if ((addrABS & 0xFF00) != addr_high) return 1; // Ô½¹ýÁË±ß½ç
    return 0;
}

// Ìí¼Ó½øÎ»
// a = a + M + C
// ±êÖ¾£º C V N Z
uint8_t Cpu::ADC()
{
    // »ñÈ¡Êý¾Ý£¬Ìí¼Óµ½ÀÛ¼ÓÆ÷ÖÐ
    fetch();

    uint16_t tmp = (uint16_t)accumulator + (uint16_t)fetched + (uint16_t)getFlag(C);
    
    setFlag(C, tmp > 255); // ÉèÖÃ½øÎ»±êÖ¾
    setFlag(Z, (tmp & 0x00FF == 0));

    uint16_t flag = ~((uint16_t)accumulator ^ (uint16_t)fetched) & (uint16_t)accumulator ^ (uint16_t)tmp;
    // ÉèÖÃÓÐ·ûºÅÒç³ö
    setFlag(V, flag & 0x0080);
    // ÉèÖÃ¸ºÊý±êÖ¾
    setFlag(N, tmp & 0x80);

    accumulator = tmp & 0x00FF; // ½«½á¹û¼ÓÔØµ½ÀÛ¼ÓÆ÷ÖÐ

    return 1;// ÐèÒª¶îÍâµÄÒ»¸öÊ±ÖÓÖÜÆÚ
}

// Âß¼­Óë²Ù×÷
// A = A & M
// N Z
uint8_t Cpu::AND()
{
    fetch();
    accumulator &= fetched;
    setFlag(Z, accumulator == 0x00);
    setFlag(N, accumulator & 0x80);
    return 1;
}

// Ëã·¨×óÒÆ
// A = C <- (A<<1) <- 0
// N Z C
uint8_t Cpu::ASL()
{
    fetch();
    uint16_t tmp = fetched << 1;
    setFlag(C, (tmp & 0xFF00) > 0);
    setFlag(Z, (tmp & 0x00FF) == 0x00);
    setFlag(N, tmp & 0x80);

    if (instructions[optCode].mode == &Cpu::IMP)
        accumulator = tmp & 0x00FF;
    else write(addrABS, tmp & 0x00FF);
    return 0;
}

// ·ÖÖ§Ö¸Áî£ºÈç¹û½øÎ»±»Çå³ý
uint8_t Cpu::BCC()
{
    if (getFlag(C) == 0) {
        cycles++;
        addrABS = pc + addrREL;

        if ((addrABS & 0xFF00) != (pc & 0xFF00)) cycles++;

        pc = addrABS;
    }
    return 0;
}

// ·ÖÖ§Ö¸Áî£º Èç¹û½øÎ»±»ÉèÖÃ
uint8_t Cpu::BCS()
{
    if (getFlag(C) == 1) {
        cycles++;
        addrABS = pc + addrREL;

        if ((addrABS & 0xFF00) != (pc & 0xFF00)) cycles++;

        pc = addrABS;
    }
    return 0;
}

uint8_t Cpu::BEQ()
{
    if (getFlag(Z) == 1) {
        cycles++;
        addrABS = pc + addrREL;

        if ((addrABS & 0xFF00) != (pc & 0xFF00)) cycles++;

        pc = addrABS;
    }
    return 0;
}

uint8_t Cpu::BIT()
{
    fetch();
    uint16_t tmp = accumulator & fetched;
    setFlag(Z, (tmp & 0x00FF) == 0x00);
    setFlag(N, fetched & (1 << 7));
    setFlag(V, fetched & (1 << 6));
    return 0;
}

//·ÖÖ§Ö¸Áî£º Èç¹ûÊÇ¸ºÊý
uint8_t Cpu::BMI()
{
    if (getFlag(N) == 1) {
        cycles++;
        addrABS = pc + addrREL;

        if ((addrABS & 0xFF00) != (pc & 0xFF00)) cycles++;

        pc = addrABS;
    }
    return uint8_t();
}

// ·ÖÖ§Ö¸Áî£ºÈç¹û²»ÏàµÈ
uint8_t Cpu::BNE()
{
    if (getFlag(Z) == 0) {
        cycles++;
        addrABS = pc + addrREL;

        if ((addrABS & 0xFF00) != (pc & 0xFF00)) cycles++;

        pc = addrABS;
    }
    return 0;
}

//·ÖÖ§Ö¸Áî£ºÈç¹ûÊÇÕýÊý
uint8_t Cpu::BPL()
{
    if (getFlag(N) == 0) {
        cycles++;
        addrABS = pc + addrREL;

        if ((addrABS & 0xFF00) != (pc & 0xFF00)) cycles++;

        pc = addrABS;
    }
    return 0;
}

// ÖÐ¶ÏÖ¸Áî
uint8_t Cpu::BRK()
{
    pc++;
    setFlag(I, 1); // ¿ªÆôÖÐ¶Ï
    write(0x0100 + stackPointer, (pc >> 8) & 0x00FF); //Ð´Èë¸ßÎ»
    stackPointer--;
    write(0x0100 + stackPointer, pc & 0x00FF); //Ð´ÈëµØÎ»
    stackPointer--;

    setFlag(B, 1); //ÖÐ¶Ï
    write(0x0100 + stackPointer, status);
    stackPointer--;
    setFlag(B, 0);

    pc = (uint16_t)read(0xFFFE) | ((uint16_t)read(0xFFFF) << 8);
    return 0;
}

// ·ÖÖ§Ö¸Áî£ºÈç¹ûÒç³ö±»Çå³ý
uint8_t Cpu::BVC()
{
    if (getFlag(V) == 0) {
        cycles++;
        addrABS = pc + addrREL;

        if ((addrABS & 0xFF00) != (pc & 0xFF00)) cycles++;

        pc = addrABS;
    }
    return 0;
}
// Èç¹ûÒç³ö±»ÉèÖÃ
uint8_t Cpu::BVS()
{
    if (getFlag(V) == 1) {
        cycles++;
        addrABS = pc + addrREL;

        if ((addrABS & 0xFF00) != (pc & 0xFF00)) cycles++;

        pc = addrABS;
    }

    return 0;
}

// Çå³ý½øÎ»±êÖ¾
uint8_t Cpu::CLC()
{
    setFlag(C, false);
    return 0;
}
// Çå³ýÊ®½øÖÆÄ£Ê½±êÖ¾
uint8_t Cpu::CLD()
{
    setFlag(D, false);
    return 0;
}
// ¹Ø±ÕÖÐ¶Ï
uint8_t Cpu::CLI()
{
    setFlag(I, false);
    return 0;
}
//Çå³ý Òç³ö±êÖ¾
uint8_t Cpu::CLV()
{
    setFlag(V, false);
    return 0;
}
// ±È½ÏÀÛ¼ÓÆ÷   
uint8_t Cpu::CMP()
{
    fetch();
    uint16_t tmp = (uint16_t)accumulator - (uint16_t)fetched;
    setFlag(C, accumulator >= fetched);
    setFlag(Z, (tmp & 0x00FF) == 0x0000);
    setFlag(N, tmp & 0x0080);
    return 1;
}

uint8_t Cpu::CPX()
{
    fetch();
    uint16_t tmp = (uint16_t)x - (uint16_t)fetched;
    setFlag(C, x >= fetched);
    setFlag(Z, (tmp & 0x00FF) == 0x0000);
    setFlag(N, tmp & 0x0080);
    return 0;
}

uint8_t Cpu::CPY()
{
    fetch();
    uint16_t tmp = (uint16_t)y - (uint16_t)fetched;
    setFlag(C, y >= fetched);
    setFlag(Z, (tmp & 0x00FF) == 0x0000);
    setFlag(N, tmp & 0x0080);
    return 0;
}

// ÄÚ´æÎ»ÖÃµÄÖµ×Ô¼õÒ»
uint8_t Cpu::DEC()
{
    fetch();
    uint16_t tmp = fetched -1;
    write(addrABS, tmp & 0x00FF);
    setFlag(Z, (tmp & 0x00FF) == 0x0000);
    setFlag(N, tmp & 0x0080);
    return 1;
}
// x¼Ä´æÆ÷µÄÖµ¼õÒ»
uint8_t Cpu::DEX()
{
    x--;
    setFlag(Z, x == 0x00);
    setFlag(N, x & 0x80);
    return 0;
}
// y¼Ä´æÆ÷µÄÖµ¼õÒ»
uint8_t Cpu::DEY()
{
    y--;
    setFlag(Z, y == 0x00);
    setFlag(N, y & 0x80);
    return 0;
}

// Òì»ò²Ù×÷
uint8_t Cpu::EOR()
{
    fetch();
    accumulator ^= fetched;
    setFlag(Z, accumulator == 0x00);
    setFlag(N, accumulator & 0x80);
    return 1;
}
// ÄÚ´æÎ»ÖÃµÄÖµ¼ÓÒ»
uint8_t Cpu::INC()
{
    fetch();
    uint16_t tmp = fetched + 1;
    write(addrABS, tmp & 0x00FF);
    setFlag(Z, (tmp & 0x00FF) == 0x0000);
    setFlag(N, tmp & 0x0080);
    return 0;
}
// x ¼Ä´æÆ÷µÄÖµ¼ÓÒ»
uint8_t Cpu::INX()
{
    x++;
    setFlag(Z, x == 0x00);
    setFlag(N, x & 0x80);
    return 0;
}

uint8_t Cpu::INY()
{
    y++;
    setFlag(Z, y == 0x00);
    setFlag(N, y & 0x80);
    return 0;
}
// Ìø×ªµ½addr_absÎ»ÖÃ
uint8_t Cpu::JMP()
{
    pc = addrABS;
    return 0;
}
// Ìø×ªµ½×ÓÀýÐÐ³ÌÐò
// ½«µ±Ç°PC Ñ¹ÈëÕ»ÖÐ£¬pc = addr_abs
uint8_t Cpu::JSR()
{
    pc--;
    write(0x0100 + stackPointer, (pc >> 8) & 0x00FF);
    stackPointer--;
    write(0x0100 + stackPointer, pc & 0x00FF);
    stackPointer--;

    pc = addrABS;
    return 0;
}
// ¸³Öµ¸øÀÛ¼ÓÆ÷
uint8_t Cpu::LDA()
{
    fetch();
    accumulator = fetched;
    setFlag(Z, accumulator == 0x00);
    setFlag(N, accumulator & 0x80);
    return 1;
}
// ¸³Öµ¸øy¼Ä´æÆ÷
uint8_t Cpu::LDY()
{
    fetch();
    y = fetched;
    setFlag(Z, y == 0x00);
    setFlag(N, y & 0x80);
    return 1;
}
// ¸³Öµ¸øx¼Ä´æÆ÷
uint8_t Cpu::LDX()
{
    fetch();
    x = fetched;
    setFlag(Z, x == 0x00);
    setFlag(N, x & 0x80);
    return 1;
}

uint8_t Cpu::LSR()
{
    fetch();
    setFlag(C, fetched & 0x0001);
    uint16_t tmp = fetched >> 1;
    setFlag(Z, (tmp & 0x00FF) == 0x0000);
    setFlag(N, tmp & 0x0080);
    if (instructions[optCode].mode == &Cpu::IMP) accumulator = tmp & 0x00FF;
    else write(addrABS, tmp & 0x00FF);

    return 0;
}

uint8_t Cpu::NOP()
{
    switch (optCode)
    {
        case 0x1C:
        case 0x3C:
        case 0x5C:
        case 0x7C:
        case 0xDC:
        case 0xFC:
            return 1;
        default: break;
    }
    return 0;
}

uint8_t Cpu::XXX()
{
    return 0;
}
// Ä£ÄâÊ±ÖÓÖÜÆÚ
void Cpu::clock()
{
    if (cycles == 0) {
        optCode = read(pc);

        setFlag(U, true); // unused ×´Ì¬±êÖ¾ Ê¼ÖÕÉèÖÃÎª1
        pc++;

        cycles = instructions[optCode].cycles;

        uint16_t addressModeAddtionalCycle = (this->*instructions[optCode].mode)();
        uint16_t operateAdditionCycle = (this->*instructions[optCode].operate)();

        cycles += (addressModeAddtionalCycle & operateAdditionCycle);

        setFlag(U, true);

       
    }
    clockCount++;

    cycles--;
}

void Cpu::reset()
{
    addrABS = 0xFFFC;
    uint16_t high = read(addrABS);
    uint16_t low = read(addrABS + 1);

    pc = (high << 8) | low;

    accumulator = 0;
    x = 0;
    y = 0;
    stackPointer = 0xFD;

    addrREL = 0x0000;
    addrABS = 0x0000;
    fetched = 0x00;

    cycles = 8;
}
// ÖÐ¶ÏÇëÇó
void Cpu::irq()
{
    // Èç¹ûÃ»ÓÐ¹Ø±ÕÖÐ¶Ï
    if (getFlag(I) == 0) {
        // ½«pcÑ¹ÈëÕ»ÖÐ
        write(0x0100 + stackPointer, (pc >> 8) & 0x00FF);
        stackPointer--;
        write(0x0100 + stackPointer, pc & 0x00FF);
        stackPointer--;
    
        setFlag(B, 0);
        setFlag(U, 1);
        setFlag(I, 1);
        write(0x0100 + stackPointer, status);
        stackPointer--;

        addrABS = 0xFFFE;
        uint16_t high = read(addrABS);
        uint16_t low = read(addrABS + 1);
        pc = (high << 8) | low;

        cycles = 7;
    }
}
// ²»ÄÜ±»ºöÂÔµÄ·ÇÑÚÊ½ÖÐ¶Ï£¬ËüºÍIRQÒ»Ñù£¬µ«ÊÇ´ÓÎ»ÖÃ 0xFFFA´¦¶ÁÈ¡µ½ÐÂµÄ³ÌÐò¼ÆÊýÆ÷µÄµØÖ·
void Cpu::nmi()
{
    write(0x0100 + stackPointer, (pc >> 8) & 0x00FF);
    stackPointer--;
    write(0x0100 + stackPointer, pc & 0x00FF);
    stackPointer--;

    setFlag(B, false);
    setFlag(U, true);
    setFlag(I, true);
    write(0x0100 + stackPointer, status);
    stackPointer--;

    addrABS = 0xFFFA;
    uint16_t high = read(addrABS);
    uint16_t low = read(addrABS + 1);
    pc = (high << 8) | low;
    cycles = 8;
}

bool Cpu::complete()
{
    return cycles == 0;
}

uint8_t Cpu::fetch()
{
    if (!(instructions[optCode].mode == &Cpu::IMP)) fetched = read(addrABS);
    return fetched;
}
// Âß¼­»ò
uint8_t Cpu::ORA()
{
    fetch();
    accumulator |= fetched;
    setFlag(Z, accumulator == 0x00);
    setFlag(N, accumulator & 0x80);
    return 1;
}
// ½«ÀÛ¼ÓÆ÷µÄÖµÑ¹ÈëÕ»ÖÐ
uint8_t Cpu::PHA()
{
    write(0x0100 + stackPointer, accumulator);
    stackPointer--;
    return 0;
}
//½«×´Ì¬¼Ä´æÆ÷Ñ¹ÈëÕ»ÖÐ£¬ÔÚÑ¹ÈëÖ®Ç° ÖÐ¶Ï±êÖ¾Ó¦¸ÃÉèÖÃÎª1
uint8_t Cpu::PHP()
{
    write(0x0100 + stackPointer, status | B | U);
    setFlag(B, 0);
    setFlag(U, 0);
    stackPointer--;
    return 0;
}
// ´ÓÕ»ÖÐµ¯³öÖµ ¸³¸øÀÛ¼ÓÆ÷
uint8_t Cpu::PLA()
{
    stackPointer++;
    accumulator = read(0x0100 + stackPointer);
    setFlag(Z, accumulator == 0x00);
    setFlag(N, accumulator & 0x80);
    return 0;
}

// ´ÓÕ»ÖÐµ¯³öÖµ ¸³¸ø×´Ì¬¼Ä´æÆ÷
uint8_t Cpu::PLP()
{
    stackPointer++;
    status = read(0x0100 + stackPointer);
    setFlag(U, 1);
    return 0;
}
// ×óÒÆ
uint8_t Cpu::ROL()
{
    fetch();
    uint16_t tmp = (uint16_t)(fetched << 1) | getFlag(C);
    setFlag(C, tmp & 0xFF00);
    setFlag(Z, (tmp & 0x00FF) == 0x0000);
    setFlag(N, tmp & 0x0080);
    if (instructions[optCode].mode == &Cpu::IMP) accumulator = tmp & 0x00FF;
    else write(addrABS, tmp & 0x00FF);
    return 0;
}
// ÓÒÒÆ
uint8_t Cpu::ROR()
{
    fetch();
    uint16_t tmp = (uint16_t)(getFlag(C) << 7) | (fetched >> 1);
    setFlag(C, tmp & 0xFF00);
    setFlag(Z, (tmp & 0x00FF) == 0x0000);
    setFlag(N, tmp & 0x0080);
    if (instructions[optCode].mode == &Cpu::IMP) accumulator = tmp & 0x00FF;
    else write(addrABS, tmp & 0x00FF);
    return 0;
}

uint8_t Cpu::RTI()
{
    stackPointer++;
    status = read(0x0100 + stackPointer);
    status &= ~B;
    status &= ~U;

    stackPointer++;
    pc = (uint16_t)read(0x0100 + stackPointer);
    stackPointer++;
    pc |= (uint16_t)read(0x0100 + stackPointer) << 8;
    pc++;
    return 0;
}

uint8_t Cpu::RTS()
{
    stackPointer++;
    pc = (uint16_t)read(0x0100 + stackPointer);
    stackPointer++;

    pc |= (uint16_t)read(0x0100 + stackPointer) << 8;
    pc++;
    return 0;
}

// ½èÈë¼õ·¨
// A = A - M - ( 1 - C )
// C V N Z 
uint8_t Cpu::SBC()
{
    fetch();
    uint16_t value = ((uint16_t)fetched) ^ 0x00FF; // ·­×ªµÍÏÂ8Î»

    uint16_t tmp = (uint16_t)accumulator + value + (uint16_t)getFlag(C);

    setFlag(C, tmp & 0xFF00);
    setFlag(Z, (tmp & 0x00FF) == 0);
    setFlag(V, (tmp ^(uint16_t)accumulator) & (tmp ^value) &0x0080);
    setFlag(N, tmp & 0x0080);

    accumulator = tmp & 0x00FF;
    return 1;
}
// ÉèÖÃ½øÎ»±êÖ¾Î»1
uint8_t Cpu::SEC()
{
    setFlag(C, true);
    return 0;
}
// ÉèÖÃÊ®½øÖÆÄ£Ê½
uint8_t Cpu::SED()
{
    setFlag(D, true);
    return 0;
}

// ¿ªÆôÖÐ¶Ï
uint8_t Cpu::SEI()
{
    setFlag(I, true);
    return 0;
}
// ÔÚ¾ø¶ÔµØÖ·´¦´æ´¢ÀÛ¼ÓÆ÷µÄÖµ
uint8_t Cpu::STA()
{
    write(addrABS, accumulator);
    return 0;
}
// ÔÚ¾ø¶ÔµØÖ·´¦´æ´¢X¼Ä´æÆ÷µÄÖµ
uint8_t Cpu::STX()
{
    write(addrABS, x);
    return 0;
}
// ÔÚ¾ø¶ÔµØÖ·´¦´æ´¢Y¼Ä´æÆ÷µÄÖµ
uint8_t Cpu::STY()
{
    write(addrABS, y);
    return 0;
}
// ½«ÀÛ¼ÓÆ÷µÄÖµ¸³¸ø x¼Ä´æÆ÷µÄ
uint8_t Cpu::TAX()
{
    x = accumulator;
    setFlag(Z, x == 0x00);
    setFlag(N, x & 0x80);
    return 0;
}
// ½«ÀÛ¼ÓÆ÷µÄÖµ¸³¸ø y¼Ä´æÆ÷
uint8_t Cpu::TAY()
{
    y = accumulator;
    setFlag(Z, y == 0x00);
    setFlag(N, y & 0x80);
    return 0;
}
// ½«Õ»Ö¸ÕëµÄÖµ¸³¸øx¼Ä´æÆ÷
uint8_t Cpu::TSX()
{
    x = stackPointer;
    setFlag(Z, x == 0x00);
    setFlag(N, x & 0x80);
    return 0;
}
// ½« x¼Ä´æÆ÷ µÄÖµ ¸³¸ø ÀÛ¼ÓÆ÷
uint8_t Cpu::TXA()
{
    accumulator = x;
    setFlag(Z, accumulator == 0x00);
    setFlag(N, accumulator & 0x80);
    return 0;
}

// ½«x¼Ä´æÆ÷µÄÖµ¸³¸øÕ»Ö¸Õë
uint8_t Cpu::TXS()
{
    stackPointer = x;
    return 0;
}
// ½«Y¼Ä´æÆ÷µÄÖµ¸³¸øÀÛ¼ÓÆ÷
uint8_t Cpu::TYA()
{
    accumulator = y;
    setFlag(Z, accumulator == 0x00);
    setFlag(N, accumulator & 0x80);
    return 0;
}
